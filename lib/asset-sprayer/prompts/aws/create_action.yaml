- model: gpt-4o-mini
  temperature: 0.0
  messages:
    - role: system
      content: >
        You are an expert cloud engineer who understands AWS API and CLI usage. Your job is to create new asset functions for use in System Initiative.

        The user will provide the current System Initiative schema API documentation.

        The user will provide the text of the help output from an AWS CLI command.

        Your job is to understand all the documents, and faithfully translate the AWS CLI command to a System Initiative asset function.

        You will use the `--cli-input-json` argument rather than specify individual arguments on the command line.

        The variable you use to construct the arguments to `--cli-input-json` will be called `cliArguments`.

        For each command line argument, you will check to see if the corresponding property has a value before inserting it into the `--cli-input-json`. For example, if the AWS CLI help text says that Tags are optional, and there are no tags in `component.properties.domain.Tags`, it should not be included in the cliArguments data structure.

        You will not set any variables that are not subsequently used in the function somewhere. For example, you will not include a line like `const domain = component.properties?.domain;` if you do not elsewhere reference the `domain` variable.

        You will populate only the arguments that have corresponding properties as arguments to the `--cli-input-json`.

        You will always check at the top of the function if the `component.properties.resource?.payload` exists, and if it does not, return an error. An example of this error follows, delimited by `:::`'s.

        :::
        if (component.properties.resource?.payload) {
            return {
                status: "error",
                message: "Resource already exists",
                payload: component.properties.resource.payload,
            };
        }
        :::

        You will map all the command line arguments to properties in the domain tree, with the property name in PascalCase. For example, given a command line argument with kebab-case like `--queue-name`, you will map it to `component.properties?.domain?.QueueName`. The exception to this rule is the `region` property, which should always be lowercase.

        You will pass the region to the command if it is required, ensuring it comes from the `component.domain?.extra?.region` property.

        You will construct the response payload by examining the Output section of the AWS CLI Command help output provided by the user. It describes a JSON data structure using a plain text description language, where each field and it's type is provided as `FieldName -> (type)`, where `FieldName` maps to a output field name and `(type)` describes its type. For example, `Procedure -> (structure)` defines a JSON object, and `Description -> (string)` defines a JSON string.

        If the Output section JSON contains only one top level field, and its type is a `structure`, return only the value of that field. An example of an input that matches this rule follows, delimited by `:::`'s.

        :::
        Policy -> (structure)

          A structure containing details about the new policy.

          PolicyName -> (string)
            The friendly name (not ARN) identifying the policy.

          PolicyId -> (string)
            The stable and unique string identifying the policy.
        :::

        Here is an example of the corresponding return value of the function delimited by `:::`s:

        :::
        const response = JSON.parse(child.stdout);

        return {
            status: "ok",
            payload: response.Policy,
        };
        :::

        If the Output section describes anything other than a single top level field, always return the full response. If the Output section describes a single top level field, but its type is not a `structure`, always return the full response. For example, here is a single top level field that is a `(string)` not a `(structure)`, delimited by `:::`'s:

        :::
        QueueUrl -> (string)
          An ID for your pants.
        :::

        Here is an example of the corresponding return value of the function delimited by `:::`'s:

        :::
        const response = JSON.parse(child.stdout);

        return {
            status: "ok",
            payload: response,
        }
        :::

        You will only use APIs that appear in the provided documentation.
    - role: user
      content: >
        What follows is the current System Initiative function API documentation as markdown, between three ^ characters.

        ^^^
        # Asset Functions Reference

        Asset functions are written in TypeScript, and executed within a sandbox
        environment using [Firecracker](https://firecracker-microvm.github.io/).

        ## Asset Function Basics

        There are 5 types of asset functions:

        * Action
        * Attribute
        * Authentication
        * Code Generation
        * Qualification

        ### Executing shell commands

        Functions frequently execute shell commands to interact with external services.
        Using the [siExec API](/reference/typescript/sandbox/exec/README).

        ```typescript
        const child = siExec.waitUntilEnd("aws", [
          "ec2",
          "describe-hosts"
        ]);
        ```

        Would execute the shell command:

        ```shell
        aws ec2 describe-hosts
        ```

        A more complex example from an action:

        ```typescript
        const child = await siExec.waitUntilEnd("aws", [
            "rds",
            "create-db-cluster",
            "--region",
            input?.properties?.domain?.Region || "",
            "--cli-input-json",
            JSON.stringify(code),
        ]);
        ```

        We're always adding more shell commands to the environment though Nix. [You can
        see the current list of included commands in the source
        code](https://github.com/systeminit/si/blob/main/flake.nix#L96).

        Send a PR if you need something added.

        ### Interacting with HTTP APIs

        The [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Window/fetch) is supported.

        ```typescript
        const webpage = await fetch("http://systeminit.com");
        ```

        ### Using lodash

        The [lodash API](https://lodash.com/docs/4.17.15) is available from the `_`
        variable, which makes working with data structures in JavaScript easy.

        ```typescript
        const result = {};
        if (component.domain?.Sid) {
          _.set(result, ["Sid"], component.domain.Sid);
        }
        ```

        If you find yourself doing complex data manipulation, lodash is where you
        should look first.

        ### Request Storage

        When a function has secrets as an input, it runs authentication functions before
        it is executed. Information is then passed between functions through the Request Storage
        API:

        ```typescript
        requestStorage.getItem("foo");
        ```

        Or to set an item (used only in authentication functions):

        ```typescript
        requestStorage.setItem("foo");
        ```

        ## Action Functions

        Action functions interact with external systems (such as AWS, GCP, or Azure)
        and return resources. They are are en-queued by users in a change set, and
        executed when applied to HEAD. The order of execution is determined
        automatically by walking the relationships between the components.

        There are four types of action function:

        1. Functions that create a resource
        2. Functions that refresh a resource
        3. Functions that delete a resource
        4. Manual functions that update or transform a resource

        Create, refresh, and delete are automatically en-queued when their relevant
        activity is taken on the diagram. Manual functions must be en-queued from the
        actions tab of the attribute panel by the user.

        ### Action function arguments

        Action functions take an `Input` argument. It has a `properties` field which contains an object that has:

        * The `si` properties

          These are the core properties set as meta-data for the function. Name, color, etc.

        * The `domain` properties

          These are the properties specified in the schema itself.

        * The `resource` data

          This is the output of the last action, stored as the state of the resource. It contains 3 fields:

          - _status_: one of "ok", "warning", or "error"
          - _message_: an optional message
          - _payload_: the resource payload itself

        * The `resource_value` data

          This is information pulled into the component properties from resource payload
          data. These are properties added with the `addResourceProp()` method of a
          components schema.

        * Any generated `code`

          Generated code is available as a map, whose key is the name of the code
          generation function that generated it.

        ### Action function return value

        Actions return a data structure identical to the resource data above. You should be careful to
        always return a payload, even on error - frequently, this is the last stored payload if it existed.

        ```typescript
        if (input?.properties?.resource?.payload) {
            return {
                status: "error",
                message: "Resource already exists",
                payload: input.properties.resource.payload,
            };
        }
        ```

        Remember that `message` is optional:

        ```typescript
        return {
            payload: JSON.parse(child.stdout).DBCluster,
            status: "ok"
        };
        ```

        Payload should be returned as a JavaScript object.

        ### Create action example

        A create action that uses generated code, `siExec` and a secret to create an AWS EKS cluster:

        ```typescript
        async function main(component: Input): Promise<Output> {
            if (component.properties.resource?.payload) {
                return {
                    status: "error",
                    message: "Resource already exists",
                    payload: component.properties.resource.payload,
                };
            }

            const code = component.properties.code?.["si:genericAwsCreate"]?.code;
            const domain = component.properties?.domain;

            const child = await siExec.waitUntilEnd("aws", [
                "eks",
                "create-cluster",
                "--region",
                domain?.extra?.Region || "",
                "--cli-input-json",
                code || "",
            ]);

            if (child.exitCode !== 0) {
                console.error(child.stderr);
                return {
                    status: "error",
                    message: `Unable to create; AWS CLI exited with non zero code: ${child.exitCode}`,
                };
            }

            const response = JSON.parse(child.stdout).cluster;

            return {
                resourceId: response.name,
                status: "ok",
            };
        }
        ```

        ### Refresh action example

        A refresh action example that uses lodash and siExec to update an AWS EKS cluster:

        ```typescript
        async function main(component: Input): Promise < Output > {
            let name = component.properties?.si?.resourceId;
            const resource = component.properties.resource?.payload;
            if (!name) {
                name = resource.name;
            }
            if (!name) {
                return {
                    status: component.properties.resource?.status ?? "error",
                    message: "Could not refresh, no resourceId present for EKS Cluster component",
                };
            }

            const cliArguments = { };
            _.set(
                cliArguments,
                "name",
                name,
            );

            const child = await siExec.waitUntilEnd("aws", [
                "eks",
                "describe-cluster",
                "--region",
                _.get(component, "properties.domain.extra.Region", ""),
                "--cli-input-json",
                JSON.stringify(cliArguments),
            ]);

            if (child.exitCode !== 0) {
                console.error(child.stderr);
                if (child.stderr.includes("ResourceNotFoundException")) {
                    console.log("EKS Cluster not found upstream (ResourceNotFoundException) so removing the resource")
                    return {
                        status: "ok",
                        payload: null,
                    };
                }
                return {
                    status: "error",
                    payload: resource,
                    message: `Refresh error; exit code ${child.exitCode}.\n\nSTDOUT:\n\n${child.stdout}\n\nSTDERR:\n\n${child.stderr}`,
                };
            }

            const object = JSON.parse(child.stdout).cluster;
            return {
                payload: object,
                status: "ok",
            };
        }
        ```

        :::warning
        Ensure you include previous resource payload on failure!
        :::

        ### Delete action example

        A delete action example that uses lodash and siExec:

        ```typescript
        async function main(component: Input): Promise<Output> {
          const cliArguments = {};
          _.set(
            cliArguments,
            "PolicyArn",
            _.get(component, "properties.resource_value.Arn"),
          );

          const child = await siExec.waitUntilEnd("aws", [
            "iam",
            "delete-policy",
            "--cli-input-json",
            JSON.stringify(cliArguments),
          ]);

          if (child.exitCode !== 0) {
            const payload = _.get(component, "properties.resource.payload");
            if (payload) {
              return {
                status: "error",
                payload,
                message:
                  `Delete error; exit code ${child.exitCode}.\n\nSTDOUT:\n\n${child.stdout}\n\nSTDERR:\n\n${child.stderr}`,
              };
            } else {
              return {
                status: "error",
                message:
                  `Delete error; exit code ${child.exitCode}.\n\nSTDOUT:\n\n${child.stdout}\n\nSTDERR:\n\n${child.stderr}`,
              };
            }
          }

          return {
            payload: null,
            status: "ok",
          };
        }
        ```

        Note that the payload returned here is `null` - this ensures the resource will be removed.

        ### Manual action example

        A manual action that updates the cluster configuration on an AWS EKS cluster, usking lodash, siExec and the AWS CLI:

        ```typescript
        async function main(component: Input) {
            const resource = component.properties.resource;
            if (!resource) {
                return {
                    status: component.properties.resource?.status ?? "ok",
                    message: component.properties.resource?.message,
                };
            }

            let json = {
                "accessConfig": {
                    "authenticationMode": component.properties.domain.accessConfig.authenticationMode,
                },
                "name": resource.name,
            };

            const updateResp = await siExec.waitUntilEnd("aws", [
                "eks",
                "update-cluster-config",
                "--cli-input-json",
                JSON.stringify(json),
                "--region",
                component.properties.domain?.extra.Region || "",
            ]);

            if (updateResp.exitCode !== 0) {
                console.error(updateResp.stderr);
                return {
                    status: "error",
                    payload: resource,
                    message: `Unable to update the EKS Cluster Access Config, AWS CLI 2 exited with non zero code: ${updateResp.exitCode}`,
                };
            }

            return {
                payload: resource,
                status: "ok"
            };
        }
        ```
        ^^^
    - role: user
      content: >
        What follows is the official documentation for an AWS CLI command as HTML, between three ^ characters.

        ^^^
        {FETCH}{AWS_CLI_DOCS_URL}/{AWS_COMMAND}/{AWS_SUBCOMMAND}.html{/FETCH}
        ^^^
    - role: user
      content: >
        Create the create action function that calls the AWS CLI command.

        Show the final function in its entirety, with no other explanation, as plain text.

        Do not wrap the code in markdown delimiters.
